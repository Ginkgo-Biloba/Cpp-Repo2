#define _CRT_SECURE_NO_WARNINGS
#include <cstdio>
#include <cstdint>
#include <string>
#include <vector>
#include <fstream>
#include <glad/glad.h>
#undef NDEBUG
#include <cassert>

class GLShader
{
	int type, ncd;
	std::vector<std::string> code;

public:
	unsigned id;

	GLShader(int shaderType)
		: type(shaderType), ncd(0), id(0)
	{
		assert((type == GL_VERTEX_SHADER)
			|| (type == GL_FRAGMENT_SHADER)
			|| (type == GL_GEOMETRY_SHADER)
			|| (type == GL_COMPUTE_SHADER)
		);
	}

	GLShader& loadStr(char const* source)
	{
		assert(id == 0);
		code.emplace_back(source);
		return *this;
	}

	GLShader& loadFile(char const* filename)
	{
		assert(id == 0);
		std::ifstream fid;
		fid.open(filename, std::ios::ate);
		if (fid.is_open())
		{
			size_t len = static_cast<size_t>(fid.tellg());
			std::string obj;
			obj.resize(len + 1);
			fid.seekg(std::ios::beg);
			fid.read(&(obj[0]), len);
			fid.close();
			code.push_back(move(obj));
		}
		return *this;
	}

	void compile()
	{
		assert(id == 0);
		id = glCreateShader(type);
		int len = static_cast<int>(code.size());
		std::vector<char const*> src;
		src.reserve(len);
		for (std::string& s : code)
			src.push_back(s.data());
		glShaderSource(id, len, src.data(), NULL);
		glCompileShader(id);
		int err;
		glGetShaderiv(id, GL_COMPILE_STATUS, &err);
		if (!err)
		{
			char info[1024];
			glGetShaderInfoLog(id, 1023, NULL, info);
			fprintf(stderr,
				"===== GLShader %u type %d COMPILE ERROR %d =====\n%s\n",
				id, type, err, info);
			fflush(stderr);
		}
	}

	void release()
	{
		if (id)
			glDeleteShader(id);
		id = 0;
		code.clear();
	}

	~GLShader()
	{
		release();
	}
};


////////////////////////////////////////////////////////////


class GLProgram
{
	int done;

public:
	unsigned id;

	GLProgram()
		: done(0), id(0)
	{
		id = glCreateProgram();
	}

	~GLProgram()
	{
		if (id)
			glDeleteProgram(id);
	}

	GLProgram& attach(GLShader const& obj)
	{
		assert(done == 0);
		glAttachShader(id, obj.id);
		return *this;
	}

	GLProgram& link()
	{
		done = 1;
		glLinkProgram(id);
		int err;
		glGetProgramiv(id, GL_LINK_STATUS, &err);
		if (!err)
		{
			char info[1024];
			glGetProgramInfoLog(id, 1023, NULL, info);
			fprintf(stderr,
				"===== GLProgram %u LINK ERROR %d ==========\n%s\n",
				id, err, info);
			fflush(stderr);
		}
		return *this;
	}

	void use()
	{
		assert(done);
		glUseProgram(id);
	}

	unsigned uniform(char const* name)
	{
		return glGetUniformLocation(id, name);
	}
};


bool ppmWrite(char const* name,
	GLubyte const* pixel, int rows, int cols, int cn, bool isrgb)
{
	char const* src = reinterpret_cast<char const*>(pixel);
	bool needrev = (cn == 3) && (!isrgb);
	int width = cols * cn;
	char header[256];
	int szhead = snprintf(header, sizeof(header),
		"P%c\n# Generated by Ginkgo\n%d %d\n255\n",
		static_cast<char>('5' + (cn == 3)), cols, rows);
	assert(cn == 1 || cn == 3);

	std::ofstream fid;
	fid.open(name, std::ios::trunc | std::ios::binary);
	if (!fid)
	{
		printf("Can not write %s\n", name);
		return false;
	}

	if (!needrev)
	{
		fid.write(header, szhead);
		fid.write(src, rows * width);
		return true;
	}

	std::string str;
	str.reserve(4 << 20);
	str += header;

	for (int h = 0; h < rows; ++h)
	{
		char const* ptr = src + h * width;
		if (str.size() + width > str.capacity())
		{
			fid.write(str.data(), str.size());
			str.clear();
		}
		str.append(ptr, width);
		if (needrev)
		{
			char* buf = &(str[str.size() - width]);
			for (int w = 0; w < width; w += 3)
			{
				buf[w + 0] = buf[w + 2];
				buf[w + 2] = buf[w + 0];
			}
		}
	}
	if (str.size())
		fid.write(str.data(), str.size());
	return true;
}


GLenum glCheckError_(const char *file, int line)
{
	GLenum errorCode;
	while ((errorCode = glGetError()) != GL_NO_ERROR)
	{
		char const* error;
		switch (errorCode)
		{
		case GL_INVALID_ENUM:                  error = "INVALID_ENUM"; break;
		case GL_INVALID_VALUE:                 error = "INVALID_VALUE"; break;
		case GL_INVALID_OPERATION:             error = "INVALID_OPERATION"; break;
		case GL_STACK_OVERFLOW:                error = "STACK_OVERFLOW"; break;
		case GL_STACK_UNDERFLOW:               error = "STACK_UNDERFLOW"; break;
		case GL_OUT_OF_MEMORY:                 error = "OUT_OF_MEMORY"; break;
		case GL_INVALID_FRAMEBUFFER_OPERATION: error = "INVALID_FRAMEBUFFER_OPERATION"; break;
		default: error = "UNKNOWN_ERROR";
		}
		printf("%s | %s (%d)\n", error, file, line);
	}
	return errorCode;
}

#define GLCheckError glCheckError_(__FILE__, __LINE__) 


void APIENTRY glDebugOutput(GLenum source,
	GLenum type, GLuint id, GLenum severity, GLsizei length,
	const GLchar* message, void* userParam)
{
	_CRT_UNUSED(length);
	_CRT_UNUSED(userParam);
	// 忽略一些不重要的错误/警告代码
	if (id == 131169 || id == 131185 || id == 131218 || id == 131204)
		return;

	char buf[1 << 10];
	std::string err;
	err += "---------------\n";
	snprintf(buf, sizeof(buf), "Debug message (%d): %s\n", id, message);
	err += buf;

	switch (source)
	{
	case GL_DEBUG_SOURCE_API:             err += "Source: API"; break;
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   err += "Source: Window System"; break;
	case GL_DEBUG_SOURCE_SHADER_COMPILER: err += "Source: Shader Compiler"; break;
	case GL_DEBUG_SOURCE_THIRD_PARTY:     err += "Source: Third Party"; break;
	case GL_DEBUG_SOURCE_APPLICATION:     err += "Source: Application"; break;
	case GL_DEBUG_SOURCE_OTHER:           err += "Source: Other"; break;
	}
	err.push_back('\n');

	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:               err += "Type: Error"; break;
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: err += "Type: Deprecated Behaviour"; break;
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  err += "Type: Undefined Behaviour"; break;
	case GL_DEBUG_TYPE_PORTABILITY:         err += "Type: Portability"; break;
	case GL_DEBUG_TYPE_PERFORMANCE:         err += "Type: Performance"; break;
	case GL_DEBUG_TYPE_MARKER:              err += "Type: Marker"; break;
	case GL_DEBUG_TYPE_PUSH_GROUP:          err += "Type: Push Group"; break;
	case GL_DEBUG_TYPE_POP_GROUP:           err += "Type: Pop Group"; break;
	case GL_DEBUG_TYPE_OTHER:               err += "Type: Other"; break;
	}
	err.push_back('\n');

	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH:         err += "Severity: high"; break;
	case GL_DEBUG_SEVERITY_MEDIUM:       err += "Severity: medium"; break;
	case GL_DEBUG_SEVERITY_LOW:          err += "Severity: low"; break;
	case GL_DEBUG_SEVERITY_NOTIFICATION: err += "Severity: notification"; break;
	}
	err.push_back('\n');

	puts(err.data());
}